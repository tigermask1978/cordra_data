Cordra validates incoming information against schemas as defined in the Type objects. Additional rules that validate and/or enrich the information in the object can be configured to be applied by Cordra at various stages of the object lifecycle. Such rules are expected to be specified in JavaScript and to be bound to the following lifecycle points:before an object is schema validated (with an opportunity, during create, to set the id or properties which help determine the id);during id generation;before sch
ema validation but after id generation;before an object is stored, allowing for additional validation or side-effects after all other validation is done;before an object is indexed, allowing the object that is indexed to differ from the one that is stored;during handle record creation;after an object (or payload) has been retrieved from storage, but before it is returned;before an object is deleted, to forbid deletion under some circumstances;after an object is deleted;after an object is created or updated;
 andbefore executing a user-supplied query.Lifecycle hooks, in our parlance, are the points of entry for your own JavaScript-based rules that Cordra processes. In addition to the lifecycle hooks that are discussed in detail below, Cordra enables clients to invoke other rules in an ad hoc fashion using Type Methods.Currently, various lifecycle hooks are enabled in Cordra for different actions: create, update, retrieve, and delete.The following diagrams illustrate hooks that are enabled during various stages 
of the object lifecycle.Most lifecycle hooks are available for use as part of the JavaScript associated with each Type object. This means if you want to leverage these hooks for multiple types of objects, then you will need to edit the JavaScript for each of the types. See Using External Modules for a method to share code among multiple types.Here is the shell of the hooks that are available in each Type, which will be explained below.Cordra provides two convenience JavaScript modules that can be imported f
or use within your JavaScript rules. These modules allow you to search and retrieve objects, and verify hashes and secrets. Additional modules allow you to retrieve schemas and associated JavaScript hooks, as discussed here. You can optionally include these modules in your JavaScript, as shown on Lines 1-4.You can also save external JavaScript libraries in Cordra for applying complex logic as discussed here.Lines 6-14 export references to the hooks that Cordra enables on a Type object: beforeSchemaValidatio
n, beforeSchemaValidationWithId, beforeStorage, objectForIndexing, onObjectResolution, onPayloadResolution, beforeDelete, afterDelete and afterUpdateOrCreate,. When handling objects, Cordra will look for methods with these names and run them if found. The methods must be exported in order for Cordra to see them. None of the methods is mandatory. You only need to implement the ones you want.Resolution of payloads will activate both onObjectResolution and onPayloadResolution. If onPayloadResolution accesses t
he output via context.directIo (see Direct I/O) the hook will fully control the output bytes, and the stored payload will not be directly returned to the client.The rest of the example shell shows the boilerplate for the methods. All, except for getAuthConfig, take both an object and a context. object is the JSON representation of the Cordra object. It may be modified and returned by beforeSchemaValidation, beforeSchemaValidationWithId, objectForIndexing, and onObjectResolution.object contains id, type, con
tent, acl, metadata, and payloads (which has payload metadata, not the full payload data). content is the user defined JSON of the object.object has the following format:context is an object with several useful properties.Property NameValueisNewFlag which is true for creations and false for modifications. Applies to beforeSchemaValidation.objectIdThe id of the object.userIdThe id of the user performing the operation.groupsA list of the ids of groups to which the user belongs.effectiveAclThe computed ACLs fo
r the object, either from the object itself or inherited from configuration. This is an object with ¡°readers¡± and ¡°writers¡± properties.aclCreateThe creation ACL for the type being created, in beforeSchemaValidation for a creation.newPayloadsA list of payload metadata for payloads being updated, in beforeSchemaValidation for an update operation.payloadsToDeleteA list of payload names of payloads being deleted, in beforeSchemaValidation for an update operation.requestContextA user-supplied requestContext quer
y parameter.payloadThe payload name for onPayloadResolution.start, endUser-supplied start and end points for a partial payload resolution for onPayloadResolution.paramsThe input supplied to a Type Methods call.directIoCan be used for more control over input/output with Type Methods or onPayloadResolution; see Direct I/O.isSearchFlag set to true in onObjectResolution if the call is being made to produce search results.isDryRunSet on a create or update according to the ¡°dryRun¡± parameter. Could be used to pre
vent external side effects.methodSet to the method name in beforeStorage or afterCreateOrUpdate when activated after an updating type method call rather than an ordinary create or update.originalObjectThe object before it was updated, in beforeStorage or afterCreateOrUpdate.beforeSchemaValidationResultThe object after beforeSchemaValidation and beforeSchemaValidationWithId but before other processing, notably before the removal of properties with secureProperty, in beforeStorage or afterCreateOrUpdate.This 
beforeStorage hook is run immediately before the object is inserted into storage. It has gone through all other processing and contains the generated id if an id was not included in the request. There is no return value for this function. As such you cannot edit the object here; however, you can perform additional validation and throw an exception if you want to reject the object.The design object (of type CordraDesign) and Type objects (of type Schema) do not have separate Type objects. These built-in type
s can still have lifecycle hooks, however. Their JavaScript modules can be defined under a property ¡°builtInTypes¡± of the design object, specifically ¡°builtInTypes.CordraDesign.javascript¡± and ¡°builtInTypes.Schema.javascript¡±. See Design Object.This getAuthConfig hook is unlike other hooks defined on a Type object in that it is not called with an instance of an object of that type.The shell for this hook is as follows:This hook, that is to be stored in the Design object, is for generating object ids when ob
jects are created. The JavaScript can be edited by selecting Design JavaScript from the Admin menu on the UI. The hook will be bound to the property ¡°javascript¡± in the Design object (so it can be edited there too, see Design Object).The shell for this hook is as follows:The flag isGenerateIdLoopable when set to true tells Cordra that if an object with the same id already exists this method can be called repeatedly until a unique id is found. If the implementation of generateId was deterministic, which is t
o say it would always return the same id for a given input object, the isGenerateIdLoopable should NOT be set to true.If null or undefined or the empty string is returned, Cordra will use its default identifier-minting logic.WarningIn versions of Cordra before 2.4.0, generateId was guaranteed to run after schema validation. Cordra 2.4.0 introduced beforeSchemaValidationWithId, which requires generateId to run before schema validation. In order to preserve backward compatibility, generateId will currently st
ill run after schema validation when beforeSchemaValidationWithId is unused; however, this flow should be considered deprecated and should not be relied on when writing new hook code. New generateId code should be robust to input which is not schema-valid, although throwing or returning null or undefined would suffice.This hook is also looked for in the ¡°javascript¡± property of the design object. It will be executed for every user request that requires authentication.See External Authentication Provider for
 a substantial example of how this hook could be used.The shell for this hook is as follows:The authInfo passed into this function has the following structure:The hook can inspect ¡°username¡± and ¡°password¡±, or ¡°token¡±, for typical authentication scenarios; but the hook also has access to the raw authentication data in various forms should it be needed.Property NameDescriptionusernameString. The username from a Basic HTTP Authorization header, or from username/password input to /auth/token or DOIP authentica
tion.passwordString. The password from a Basic HTTP Authorization header, or from username/password input to /auth/token or DOIP authentication.tokenString. The Bearer token from a Bearer HTTP Authorization header, or a JWT assertion made as /auth/token input, or a token from DOIP authentication.authHeaderString. The value of the request¡¯s HTTP Authorization header.authTokenInputObject. The input to the /auth/token endpoint or the 20.DOIP/Op.Auth.Token operation. See Create a new access token.doipAuthentica
tionObject. If the request come in over the DOIP interface this property will contain the the value of the passed in DOIP authentication.doipClientIdString. If the request came in over the DOIP interface this property will contain the clientId, if available.asUserIdString. The asUserId property may be optionally set to indicate that the call should should be performed with the permissions that user has been granted; see As-User.Many authenticate hook use cases can ignore this.Default Cordra authentication l
ogic only allows admin to use As-User; the authenticate hook can handle the As-User request by returning a userId which has the value of the provided asUserId, and can allow users other than admin as desired. Only set the output userId to the input asUserId when you really want to allow the authenticating user the full privileges of the asUserId. If the hook return userId does not match the input asUserId, the default As-User logic will occur; to prevent even admin use of As-User, throw an exception.Note th
at if this property is set, and you are returning custom groupIds which you wish to be available using As-User, you should set userId to the asUserId, and return the groupIds for the asUserId.Returning null or undefined causes the default cordra authentication code to be executed in that case.To reject an authentication attempt throw an exception.To accept an authentication return a result object. The result object should contain at least "active": true and the userId. It can optionally contain username and
 groupIds, where groupIds are the groups the user is a member of.The active property on the result object should be set to true. If it is set to false it will cause an exception to be thrown.WarningNote that the userId ¡°admin¡± will be given the full privileges of the Cordra admin user. Thus take care that the behavior of any external authentication provider used by the authenticate hook does not give users full control over their own userIds.An example successful authentication result object is shown below:
Property NameDescriptionactiveBoolean. Set to true if the authentication is successful.userIdString. The userId of the authenticated user.usernameString (Optional). The username of the authenticated user.groupIdsList of String (Optional). Custom groupIds the authenticated user is a member of.bypassCordraGroupObjectsBoolean (Optional) Used in combination with groupIds. If set to true only the returned groupIds will be used. If missing or set to false any Cordra group objects that contain this users id will b
e combined with the custom groupIds.grantAuthenticatedAccessBoolean (Optional). If set to true this user is considered ¡°authenticated¡± by ACLs that use that keyword. If missing Cordra ACLs will only consider this user ¡°authenticated¡± if their exists a Cordra object that corresponds with their userId. If a hook allows authentication by a wide open set of users, such as any users with an account with some existing global service, then it would be appropriate to set this false. If your ACLs do not use the ¡°aut
henticated¡± keyword, this has no effect.expNumber (Optional). Expiration in Epoch Unix Timestamp, the number of seconds since JAN 01 1970. (UTC) that the session should last for before expiration. If not supplied by default the session will not expire.There is one additional special response which the authenticate hook can return:This response causes Cordra to behave as if there was no authentication attempt.WarningIt is possible to lock out all users, including admin, by throwing an exception from the auth
enticate hook. Doing so would then prevent admin from signing in to edit the problem JavaScript. To recover from such a situation place the following example repoInit.json file in the data directory. Upon restart, this will delete all the JavaScript on the design object allowing admin to sign in to fix it.This hook is also looked for in the ¡°javascript¡± property of the design object. It will be executed for every user-supplied query to the Search API. It can be used for example to restrict the query to excl
ude certain objects based on the calling user. It can also be used to modify the query params supplied by the user for example to restrict the number of results per page, or to throw an exception when a user uses search parameters which are to be disallowed to that user. Query restriction can be accomplished either by altering the query or adding filterQueries (see Search for objects).The shell for this hook is as follows:This hook is similar to the above-mentioned customizeQueryAndParams but only allows cu
stomization of the query string. If hooks customizeQueryAndParams and customizeQuery are both implemented, both will be executed with customizeQuery being run after.The shell for this hook is as follows:This hook is for specifying the handle record that is to be returned when handles are resolved using handle client tools. This hook is on the separate Design object property design.handleMintingConfig.javascript, which can be edited by selecting Handle Records from the Admin menu on the UI.The shell for this
 hook is as follows:If creating handle values with JavaScript it is important to consider that all Cordra objects, even if not publicly visible, will have a handle record created. If you are storing data directly in the handle record you may wish to check if the Cordra object is publicly accessible. You can do this by inspecting the ¡®context¡¯ argument. For example:The return value of any hook (or type method) can be a JavaScript promise. When a hook returns a promise, Cordra will wait until the promise is f
ulfilled or rejected. If the promise is fulfilled, Cordra will use the value to which the promise resolved. If the promise is rejected, Cordra will treat the rejection reason like it would a thrown exception. This facility makes it possible to use asynchronous libraries to write Cordra hooks and type methods.Errors thrown in as strings will end up in the server response, with the thrown string as the error message.If the user requests are issued via the REST API, for beforeSchemaValidation and Type methods 
calls, this will be returned to the user as a 400 Bad Request. For onObjectResolution and beforeDelete, this will be returned as 403 Forbidden. For search results where onObjectResolution throws an exception, the corresponding object will be omitted from the search results (this can affect search results count).If the user requests are issued via the DOIP interface, a ¡°bad request¡± or ¡°forbidden¡± error will be returned.For more control over the server response, you can also throw a custom CordraError, avail
able via the Cordra.js Module. For example:This will be translated into a server response with the given error message and response status code. If present, the response object will be added to the body of the server response. This can be used to send extra information about the error back to the caller.As a convenience, if the first argument to new cordra.CordraError is a string, the response will be {"message":"that string"}.Thrown errors other than strings and CordraError will be seen by the user as 500 
Internal Server Error.The builtin Cordra.js module has helpful functions, listed below, that may be useful when writing JavaScript code in Type methods.Note: Lifecycle hooks are triggered when calls are made using the external APIs. Calls made to Cordra using the helpful functions in the cordra.js module do not trigger any lifecycle hooks.Use the search function to find objects in the Cordra index:This will return an array (in JSON sense) of Cordra objects matching the query. params is an optional object wi
th optional fields pageNum, pageSize, sortFields, facets, and filterQueries.The default behavior is to get all results for a query, which corresponds to a pageNum of 0 and pageSize of -1. Caution should be used when requesting all results when the query might match a very large number of objects.The legacy form cordra.search(query, pageNum, pageSize, sortFields) still functions as well.Note: Former versions of Cordra would return all results with pageSize=0. To restore this former behavior, you can add "use
LegacySearchPageSizeZeroReturnsAll":true to the Cordra Design object. By default a search with pageSize=0 returns the number of matched objects but no object content.Use get to get an object from Cordra by the object ID:If an object with the given ID is found, it will be returned. Otherwise, null will be returned.Use any of the following to retrieve a payload from Cordra using the object ID and the payload name:See Throwing Errors in Schema JavaScript.Will modify a string for literal inclusion in a phrase q
uery for calling cordra.search:Used to verify a given string against the hash stored for that property:Return true or false, depending on the results of the verification.Verifies the hashes on a cordra object property:Returns a verification report object indicating which of the object hashes verify.Hashes a JSON object, JSON array or primitive:Returns a base16 encoded string of the SHA-256 hash (or other specified algorithm) of the input. The input JSON is first canonicalized before being hashed.Signs a pay
load (a string) with a given private key in JWK format:Returns a Json Web Signature in compact serialization.Signs a payload (a string) with the private key of the Cordra instance:Returns a Json Web Signature in compact serialization.The private key used is the same key used for administering an external handle server, and can be set by including a file ¡°privatekey¡± in the Cordra data directory. See Handle Server and also Cordra Configuration for the distributed version.Returns the Cordra public key in JWK 
format:Verifies a JWS with the private key of the Cordra instance:Verifies a JWS with the supplied private key in JWK format:Extracts the payload of a JWT, returning the parsed JSON as a JavaScript object:Given a user id, returns a list of group ids, which are the Cordra group objects that reference the user id. Does not interact with custom groups provided by the response of the ¡°authenticate¡± hook.Given some variable input and a JSON schema, this function will validate the input against the JSON schema an
d return a report:The resulting report with contain a boolean success and possibly a list of errors, where each error will have a message and possibly a pointer indicating where in the JSON the error occurs.The JsonSchema may use $ref to reference other schemas in Cordra. For example if you have a Cordra type named Foo you could do the following:Schemas associated with type objects are available to the JavaScript via require('/cordra/schemas/Type.schema.json'), and JavaScript added to those type objects via
 require('/cordra/schemas/Type'). Here Type should be replaced by the name of the particular type to be accessed.External JavaScript modules can be managed with a Cordra object as a payload configured to be a ¡°referrable¡± source of JavaScript modules. Typically, this can be done on a single object of a type called JavaScriptDirectory. Here are the steps needed to create and populate the JavaScriptDirectory object.Create a new schema in Cordra called ¡°JavaScriptDirectory¡± and using the ¡°javascript-directory¡±
 template.Create a new JavaScriptDirectory object. Set the directory to /node_modules. This will allow you to import modules by filename, instead of directory path and filename.Add your JavaScript module files as payloads to the JavaScriptDirectory object. The payload name should match the filename and will be used when importing a module. For example, a payload named util.js could be importing using require('util');The use of external JavaScript modules affects reindexing. It is currently necessary to ensu
re that objects of type ¡°Schema¡± and any sources of JavaScript (like type ¡°JavaScriptDirectory¡±) are indexed first. See Reindexing for information.Cordra uses the Nashorn JavaScript Engine packaged with Java. The version of JavaScript supported depends on the version of Java used to run Cordra. Java 8 supports ECMAScript 5.1. As of the time of this writing, Java 9 supports some but not all ECMAScript 6 features.Cordra JavaScript does come prepopulated with a wide range of polyfills allowing features up to E
CMAScript 2017. It is thus in many cases straightforward to write ECMAScript 2017 code and transpile it (using for example Babel) to ES5 for use in Cordra.In Java, there is a limit on the size of a single function. It is rare to run up against this limit writing Java code, but it can happen when JavaScript is compiled to Java. This is especially true when using third-party libraries, which may be minified in one large function. If you hit this limit, you will see the error ¡°Code Too Large¡± in your logs.In e
arly versions of the Cordra 2.0 Beta software, the JavaScript hooks beforeSchemaValidation, onObjectResolution, and beforeDelete took the JSON content of the Cordra object, instead of the full Cordra object (including id, type, content, acl, metadata, and payloads properties). Additionally the JavaScript cordra.get function returned only the content instead of the full Cordra object.If a Cordra instance with JavaScript written for those earlier versions needs to be upgraded, and it is not yet possible to ad
apt the JavaScript to the current API, then the following flag must be added to the Design object:For more information on editing the Design object, see Design Object.Cordra users upgrading from early versions of the Cordra 2.0 beta, who did not use schema JavaScript (apart from the default User schema JavaScript, which will be automatically upgraded if it has not been edited), do not in general need to take any action.The default Cordra User schema comes with JavaScript that performs basic password validat
ion.This code will run before the given object is validated and stored. If this request is a create (context.isNew is true) or contains a password, the password is checked to make sure it is long enough. If not, an error is thrown. This error will be returned to the callee and can be displayed as desired.In this slightly more complicated example, we will bind lifecycle hooks to the Document type pre-defined in Cordra with the following features:Add a timestamp to the description of the document in a way it 
is stored.Add a timestamp to the description when the object is resolved, but not actually store.Require that the description be changed to ¡°DELETEME¡± before the document can be deleted.To demonstrate loading JavaScript from an external file, the function to create the timestamp is in a file called util.js. Create a JavaScript Directory (as described above) and upload this file as a payload named util.js.Next, edit the Document type in Cordra and put the following in the JavaScript field.Finally, create a n
ew document in Cordra. You should see that whenever the document is updated, a new timestamp is appended to the description. If you view the document¡¯s JSON, you should see a single resolution timestamp, which changes on every resolution. Finally, if you try to delete the document without changing the description to ¡°DELETEME¡± you should see an error message.It is possible make changes to the object that is indexed such that it differs from the object that is stored. This is achieved by writing a function c
alled objectForIndexing.In this example if the incoming object has a property called name with the value foo, a new property will be added to the indexed object called otherName with the value bar. The object that is stored will not contain the new property but you will be able to search for this object via this property with the query /otherName:bar.Example JavaScript for generating object ids is shown below. Here we generate a random suffix for the handle in base16 and append it to a prefix. By setting is
GenerateIdLoopable to true, we ask Cordra to repeatedly call this method until a unique id is generated.Example JavaScript for creating handle values is shown below. The JavaScript puts a copy of the information from the Cordra object in the Handle record.